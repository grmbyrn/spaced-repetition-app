{
  "language": "rust",
  "title": "Rust",
  "chapters": [
    {
      "id": "installation",
      "title": "Rust Installation, Hello World, Hello Cargo",
      "resourceUrl": "https://www.youtube.com/watch?v=R33h77nrMqc&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=1&pp=iAQB",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson01.rs",
      "questions": [
        {
          "id": "rust1a",
          "questionText": "What kind of programming language is Rust?",
          "options": [
            "Interpreted, dynamically typed",
            "Compiled, statically typed",
            "Interpreted, statically typed",
            "Compiled, dynamically typed"
          ],
          "correctIndex": 1,
          "explanation": "Rust is a compiled language (using rustc) and uses static typing, which helps catch many errors at compile time."
        },
        {
          "id": "rust1b",
          "questionText": "What is the main advantage of using Cargo over manually using rustc?",
          "options": [
            "Cargo can only run unit tests",
            "Cargo creates executables for Python",
            "Cargo simplifies project structure and builds",
            "Cargo allows editing source code in a browser"
          ],
          "correctIndex": 2,
          "explanation": "Cargo is Rust’s package manager and build tool, streamlining compilation, dependencies, and project setup."
        },
        {
          "id": "rust1c",
          "questionText": "What does the exclamation mark in println! indicate in Rust?",
          "options": [
            "It is a syntax error",
            "It denotes a macro, not a regular function",
            "It marks the function as unsafe",
            "It is optional and can be removed"
          ],
          "correctIndex": 1,
          "explanation": "In Rust, macros like println! use ! to distinguish them from regular functions."
        },
        {
          "id": "rust1d",
          "questionText": "What is the function of the cargo check command?",
          "options": [
            "Compiles and runs the program",
            "Checks syntax and logic but doesn’t compile",
            "Checks for compilation errors without generating executable",
            "Updates all dependencies"
          ],
          "correctIndex": 2,
          "explanation": "cargo check is used for fast syntax and type-checking, without building the binary."
        },
        {
          "id": "rust1e",
          "questionText": "What is the significance of cargo build --release?",
          "options": [
            "It builds the debug version of the app",
            "It builds a slower, more verbose version of the binary",
            "It creates an optimized, production-ready binary",
            "It updates all dependencies and compiles"
          ],
          "correctIndex": 2,
          "explanation": "--release enables compiler optimizations, producing faster and smaller binaries for production use."
        }
      ]
    },
    {
      "id": "variables",
      "title": "Variables, Shadowing, Constants",
      "resourceUrl": "https://www.youtube.com/watch?v=6Ag0MZUlvBE&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=2&pp=iAQB0gcJCccJAYcqIYzv",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson02.rs",
      "questions": [
        {
          "id": "rust2a",
          "questionText": "In Rust, what is the default mutability of variables declared using let?",
          "options": [
            "Mutable",
            "Immutable",
            "Depends on the data type",
            "Mutable only inside functions"
          ],
          "correctIndex": 1,
          "explanation": "In Rust, variables declared with let are immutable by default. You must explicitly use mut if you want to make them mutable (e.g., let mut x = 5)."
        },
        {
          "id": "rust2b",
          "questionText": "What happens when you try to change the type of a mutable variable in Rust (e.g., from i32 to &str)?",
          "options": [
            "The program compiles and runs",
            "Rust automatically converts the type",
            "A compile-time type error occurs",
            "The value becomes a union type"
          ],
          "correctIndex": 2,
          "explanation": "In Rust, mutability only allows changing the value, not the type. Changing from an integer to a string causes a type mismatch error."
        },
        {
          "id": "rust2c",
          "questionText": "What is “shadowing” in Rust?",
          "options": [
            "When a variable becomes inaccessible due to an if statement",
            "Declaring a variable of the same name in a new scope or with a new value/type",
            "A way to make constants mutable",
            "A feature that allows functions to override variables"
          ],
          "correctIndex": 1,
          "explanation": "Shadowing allows you to declare a new variable with the same name, even with a different type, which replaces the previous binding in that scope."
        },
        {
          "id": "rust2d",
          "questionText": "What is a key requirement when declaring constants (const) in Rust?",
          "options": [
            "They must be declared inside a function",
            "They must use lowercase snake_case naming",
            "Their type must be explicitly declared",
            "They can be reassigned once"
          ],
          "correctIndex": 2,
          "explanation": "Rust requires explicit type annotations when declaring constants, unlike regular let bindings where the compiler often infers the type."
        },
        {
          "id": "rust2e",
          "questionText": "Which of the following is NOT allowed in Rust?",
          "options": [
            "Reassigning a mut variable's value",
            "Shadowing an immutable variable",
            "Declaring a constant without assigning a value immediately",
            "Declaring two variables of the same name in different scopes"
          ],
          "correctIndex": 2,
          "explanation": "Constants must be initialized at the point of declaration. You cannot declare them and assign a value later like you can with let."
        }
      ]
    },
    {
      "id": "data-types",
      "title": "Data Types in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=NyqJp5M3hRE&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=3&pp=iAQB",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson03.rs",
      "questions": [
        {
          "id": "rust3a",
          "questionText": "Which of the following is not a scalar type in Rust?",
          "options": [
            "i32",
            "f64",
            "char",
            "tuple"
          ],
          "correctIndex": 3,
          "explanation": "tuple is a compound type, not a scalar. Scalar types in Rust include integers, floating-point numbers, booleans, and characters."
        },
        {
          "id": "rust3b",
          "questionText": "What is the default floating-point type in Rust when you write a number like 3.14?",
          "options": [
            "f32",
            "float",
            "f64",
            "double"
          ],
          "correctIndex": 1,
          "explanation": "Rust defaults to f64 for floating-point literals, providing double-precision by default for better accuracy."
        },
        {
          "id": "rust3c",
          "questionText": "What will happen if you declare a boolean variable in Rust without initializing it?",
          "options": [
            "It gets a default value of false",
            "It gets a default value of true",
            "It is automatically inferred",
            "It results in a compile-time error"
          ],
          "correctIndex": 3,
          "explanation": " In Rust, all variables must be initialized before use, including booleans. Failing to do so results in a compiler error."
        },
        {
          "id": "rust3d",
          "questionText": "Which of the following correctly distinguishes a struct from a tuple in Rust?",
          "options": [
            "Structs store values of the same type, tuples do not",
            "Tuples have named fields, structs do not",
            "Structs have named fields, tuples do not",
            "Tuples are only for floating-point values"
          ],
          "correctIndex": 2,
          "explanation": "Structs are like records with named fields (e.g., name: String), while tuples are ordered collections accessed by index."
        },
        {
          "id": "rust3e",
          "questionText": "What is true about the match statement in Rust when used with an enum?",
          "options": [
            "You must only match one of the enum values",
            "The enum must implement the Default trait",
            "All possible enum variants must be handled",
            "match works only with numeric types"
          ],
          "correctIndex": 2,
          "explanation": "Rust’s match statement is exhaustive — you must cover all possible enum variants unless you use a wildcard _ arm."
        }
      ]
    },
    {
      "id": "functions",
      "title": "Functions in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=hJLc2Zu405A&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=4&pp=iAQB",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson04.rs",
      "questions": [
        {
          "id": "rust4a",
          "questionText": "What keyword is used to declare a function in Rust?",
          "options": [
            "function",
            "fn",
            "def",
            "func"
          ],
          "correctIndex": 1,
          "explanation": "Rust uses the 'fn' keyword to declare functions."
        },
        {
          "id": "rust4b",
          "questionText": "In Rust, why must the type of function parameters be specified?",
          "options": [
            "To allow the function to compile faster",
            "Because Rust is statically typed and requires knowing types at compile time",
            "To enable dynamic typing at runtime",
            "It is optional and depends on the function"
          ],
          "correctIndex": 1,
          "explanation": "Rust requires explicit parameter types because it is statically typed and needs this information at compile time."
        },
        {
          "id": "rust4c",
          "questionText": "What is the difference between a statement and an expression in Rust?",
          "options": [
            "Statements return values; expressions do not",
            "Expressions return values; statements do not",
            "Both always return values",
            "Neither return values"
          ],
          "correctIndex": 1,
          "explanation": "In Rust, expressions evaluate to a value, whereas statements perform actions but do not return a value."
        },
        {
          "id": "rust4d",
          "questionText": "How do you return a value from a Rust function without using the 'return' keyword?",
          "options": [
            "By ending the function with a semicolon",
            "By placing the value expression as the last line without a semicolon",
            "By using a 'yield' keyword",
            "You must always use the 'return' keyword"
          ],
          "correctIndex": 1,
          "explanation": "Rust functions return the value of the last expression without a semicolon; adding a semicolon turns it into a statement and discards the value."
        },
        {
          "id": "rust4e",
          "questionText": "What is the naming convention for functions in Rust?",
          "options": [
            "CamelCase",
            "snake_case",
            "PascalCase",
            "kebab-case"
          ],
          "correctIndex": 1,
          "explanation": "Functions in Rust are conventionally named using snake_case."
        }
      ]
    },
    {
      "id": "control_flow",
      "title": "Control Flow in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=2w_FTiD74JI&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=5&pp=iAQB",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson05.rs",
      "questions": [
        {
          "id": "rust5a",
          "questionText": "What makes it possible to assign the result of an if expression to a variable in Rust?",
          "options": [
            "Rust automatically converts if statements into functions",
            "All expressions in Rust return a tuple",
            "If expressions in Rust are evaluated and return a value",
            "Rust allows dynamic typing for if statements"
          ],
          "correctIndex": 2,
          "explanation": "In Rust, if is an expression, meaning it evaluates to a value and can be used where a value is expected, like in variable assignments."
        },
        {
          "id": "rust5b",
          "questionText": "What will happen if a match expression does not cover all possible enum variants?",
          "options": [
            "It will compile, but produce a runtime warning",
            "It will compile with a deprecation notice",
            "It will fail to compile due to non-exhaustive patterns",
            "It will default to the first pattern automatically"
          ],
          "correctIndex": 2,
          "explanation": "Rust requires all match expressions to be exhaustive; missing a variant will result in a compile-time error."
        },
        {
          "id": "rust5c",
          "questionText": "Which keyword is used to exit a loop and optionally return a value?",
          "options": [
            "continue",
            "exit",
            "return",
            "break"
          ],
          "correctIndex": 3,
          "explanation": "The break keyword exits a loop, and in Rust, it can return a value when used inside loop expressions."
        },
        {
          "id": "rust5d",
          "questionText": "What is the correct syntax to iterate over a range of numbers from 1 to 4 (inclusive) in Rust?",
          "options": [
            "for number in 1..4",
            "for number in 1..=4",
            "for number = 1 to 4",
            "for (number in range(1, 5))"
          ],
          "correctIndex": 1,
          "explanation": "`1..=4` is an inclusive range in Rust, meaning it includes both 1 and 4. `1..4` would exclude 4."
        },
        {
          "id": "rust5e",
          "questionText": "Why do we need to add the `mut` keyword when modifying a variable inside a loop?",
          "options": [
            "Because variables are immutable by default in Rust",
            "Because loops in Rust only work with mutable variables",
            "Because the compiler can’t infer variable types without `mut`",
            "Because `mut` is required for all numerical operations"
          ],
          "correctIndex": 0,
          "explanation": "In Rust, variables are immutable by default, so you must explicitly declare them mutable with `mut` to change their value."
        },
        {
          "id": "rust5f",
          "questionText": "What does the `continue` keyword do in a loop?",
          "options": [
            "Exits the loop entirely",
            "Pauses the loop and waits for user input",
            "Skips the current iteration and starts the next",
            "Repeats the current iteration"
          ],
          "correctIndex": 2,
          "explanation": "`continue` skips the remaining code in the current loop iteration and proceeds with the next iteration."
        },
        {
          "id": "rust5g",
          "questionText": "What is the purpose of using `.chars()` when iterating over a string?",
          "options": [
            "It converts the string into a list of numbers",
            "It reverses the string characters",
            "It splits the string into individual characters",
            "It transforms each character into its Unicode value"
          ],
          "correctIndex": 2,
          "explanation": "The `.chars()` method returns an iterator over the characters of a string, allowing character-by-character processing."
        },
        {
          "id": "rust5h",
          "questionText": "In the FizzBuzz example, which condition should be checked first?",
          "options": [
            "Divisible by 3",
            "Divisible by 5",
            "Divisible by both 3 and 5",
            "None, order doesn’t matter"
          ],
          "correctIndex": 2,
          "explanation": "The check for divisibility by both 3 and 5 must come first, otherwise individual checks for 3 or 5 will match first and skip the combined condition."
        }
      ]
    },
    {
      "id": "ownership",
      "title": "Understanding Ownership in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=9VBLOwmNE1g&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=6&pp=iAQB",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson06.rs",
      "questions": [
        {
          "id": "rust6a",
          "questionText": "What is the primary goal of Rust’s ownership system?",
          "options": [
            "To enable faster GUI rendering",
            "To manage heap data safely and efficiently",
            "To avoid all types of memory allocation",
            "To automatically create backup copies of data"
          ],
          "correctIndex": 1,
          "explanation": "Ownership in Rust helps manage heap-allocated data safely and efficiently without a garbage collector."
        },
        {
          "id": "rust6b",
          "questionText": "What happens to a variable’s value when it goes out of scope in Rust?",
          "options": [
            "It is ignored by the compiler",
            "It is manually freed using a `free()` call",
            "Rust automatically calls the `drop` function",
            "It stays in memory until the program ends"
          ],
          "correctIndex": 2,
          "explanation": "Rust automatically calls the `drop` function when a value goes out of scope to free heap memory."
        },
        {
          "id": "rust6c",
          "questionText": "Why does assigning one `String` variable to another cause a compile error in Rust?",
          "options": [
            "Because Strings can’t be reassigned",
            "Because Strings require explicit memory allocation",
            "Because the ownership of the heap data is moved to the new variable",
            "Because String is a constant type"
          ],
          "correctIndex": 2,
          "explanation": "When a `String` is assigned to another variable, ownership of the heap data moves, invalidating the original variable."
        },
        {
          "id": "rust6d",
          "questionText": "What does the `.clone()` method do when called on a `String`?",
          "options": [
            "Deletes the existing string and returns a pointer",
            "Performs a shallow copy of the string",
            "Creates a deep copy of the string's heap data",
            "Changes the string to a literal"
          ],
          "correctIndex": 2,
          "explanation": "The `.clone()` method performs a deep copy of the heap data, preserving both the original and the clone."
        },
        {
          "id": "rust6e",
          "questionText": "Why do integers not require `.clone()` to be reassigned in Rust?",
          "options": [
            "Because integers are dynamically typed",
            "Because integers are always stored on the heap",
            "Because integers implement the `Copy` trait",
            "Because integers use reference counting"
          ],
          "correctIndex": 2,
          "explanation": "Types like integers are stored on the stack and implement the `Copy` trait, making trivial copying safe and efficient."
        },
        {
          "id": "rust6f",
          "questionText": "Which type of memory is used for storing values of unknown or dynamic size in Rust?",
          "options": [
            "Stack",
            "Cache",
            "Heap",
            "Register"
          ],
          "correctIndex": 2,
          "explanation": "The heap is used for dynamically sized or unknown-sized values, while the stack is for fixed-size data."
        },
        {
          "id": "rust6g",
          "questionText": "What is a key difference between stack and heap memory in Rust?",
          "options": [
            "Stack memory is used for strings only",
            "Heap memory can’t store numeric types",
            "Stack memory is fast and has fixed size data; heap is slower and used for dynamic data",
            "Heap memory is used for function pointers only"
          ],
          "correctIndex": 2,
          "explanation": "Stack memory is fast and stores fixed-size data; heap memory is slower and used for dynamic allocations."
        },
        {
          "id": "rust6h",
          "questionText": "Which trait prevents a type from also implementing the `Copy` trait?",
          "options": [
            "Clone",
            "Drop",
            "Debug",
            "PartialEq"
          ],
          "correctIndex": 1,
          "explanation": "Types that implement the `Drop` trait cannot also implement `Copy`, as automatic duplication could lead to double frees."
        },
        {
          "id": "rust6i",
          "questionText": "What happens when a value is passed to a function in Rust?",
          "options": [
            "The value is always cloned",
            "The value’s ownership is moved unless it implements `Copy`",
            "Only a reference to the value is used",
            "The value is ignored by the function"
          ],
          "correctIndex": 1,
          "explanation": "Unless a type implements the `Copy` trait, passing it to a function moves ownership and invalidates the original variable."
        },
        {
          "id": "rust6j",
          "questionText": "Why does Rust avoid performing deep copies by default when using `=`?",
          "options": [
            "Deep copies are unsafe in systems programming",
            "Deep copies can introduce runtime panics",
            "Deep copies are expensive in terms of performance",
            "Rust uses immutable references for all assignments"
          ],
          "correctIndex": 2,
          "explanation": "Rust avoids deep copies unless explicitly requested with `.clone()` because cloning heap data is expensive."
        }
      ]
    },
    {
      "id": "references-and-borrowing",
      "title": "References and Borrowing in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=Q_0yoX07Fhs&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=7&ab_channel=FrancescoCiulla",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson07.rs",
      "questions": [
        {
          "id": "rust7a",
          "questionText": "What happens when you pass a String to a function in Rust without using a reference?",
          "options": [
            "The String is cloned automatically",
            "The function borrows the String temporarily",
            "Ownership of the String is moved to the function",
            "The String becomes immutable"
          ],
          "correctIndex": 2,
          "explanation": "Passing a String without a reference moves ownership to the function. This means the original variable can no longer be used unless ownership is returned."
        },
        {
          "id": "rust7b",
          "questionText": "Why can integers be used after being passed to a function in Rust?",
          "options": [
            "Because they are stored on the heap",
            "Because integers implement the Copy trait",
            "Because Rust automatically creates references",
            "Because they are immutable"
          ],
          "correctIndex": 1,
          "explanation": "Integers implement the Copy trait, so they are copied rather than moved when passed to functions."
        },
        {
          "id": "rust7c",
          "questionText": "What does borrowing mean in Rust?",
          "options": [
            "Creating a mutable variable from another variable",
            "Passing ownership of a value to another function",
            "Temporarily using a value without taking ownership",
            "Duplicating a value to avoid ownership issues"
          ],
          "correctIndex": 2,
          "explanation": "Borrowing refers to temporarily accessing a value via a reference without taking ownership, allowing the original owner to retain control."
        },
        {
          "id": "rust7d",
          "questionText": "Which of the following best describes Rust's rule about mutable references?",
          "options": [
            "You can have any number of mutable references",
            "You can only have one mutable reference or many immutable ones at a time",
            "Mutable references must be declared inside functions",
            "Mutable references are unsafe and discouraged"
          ],
          "correctIndex": 1,
          "explanation": "Rust enforces that you may have one mutable reference or any number of immutable references, but not both at the same time in the same scope."
        },
        {
          "id": "rust7e",
          "questionText": "What is a dangling reference in Rust?",
          "options": [
            "A reference to a variable that has been dropped",
            "A variable that is declared but not used",
            "A type mismatch between two variables",
            "A bug in Rust's memory allocator"
          ],
          "correctIndex": 0,
          "explanation": "A dangling reference occurs when a reference points to memory that has already been freed or is out of scope. Rust prevents this at compile time."
        },
        {
          "id": "rust7f",
          "questionText": "How can you avoid moving a String into a function while still accessing it inside?",
          "options": [
            "Pass the String as a mutable reference",
            "Pass a reference to the String (e.g., &s)",
            "Convert the String to a static type",
            "Use the Copy trait"
          ],
          "correctIndex": 1,
          "explanation": "By passing a reference (e.g., `&s`), you borrow the String and avoid transferring ownership, so the original value remains usable."
        },
        {
          "id": "rust7g",
          "questionText": "What does Rust require to modify a borrowed value?",
          "options": [
            "The variable must be cloned first",
            "The reference must be immutable",
            "The reference must be mutable",
            "The variable must be defined in main()"
          ],
          "correctIndex": 2,
          "explanation": "To modify a borrowed value, you must use a mutable reference (`&mut`), and the original variable must also be declared as mutable."
        },
        {
          "id": "rust7h",
          "questionText": "Why does Rust not allow both mutable and immutable references at the same time?",
          "options": [
            "Because it violates static typing",
            "To prevent race conditions and ensure memory safety",
            "To optimize compiler performance",
            "Because functions can't handle both reference types"
          ],
          "correctIndex": 1,
          "explanation": "Allowing both mutable and immutable references at the same time could lead to data races. Rust enforces this rule at compile time for safety."
        },
        {
          "id": "rust7i",
          "questionText": "What does the function signature `fn calculate_length(s: &String) -> usize` signify?",
          "options": [
            "The function returns the length and the original string",
            "The function takes ownership of a String and returns its size",
            "The function borrows a String and returns its length",
            "The function creates a new String based on input"
          ],
          "correctIndex": 2,
          "explanation": "The `&String` in the parameter means the function borrows the string, and it returns the length without taking ownership."
        },
        {
          "id": "rust7j",
          "questionText": "How does Rust prevent functions from returning dangling references?",
          "options": [
            "By disallowing return statements with references",
            "By forcing the use of the Copy trait",
            "By tracking lifetimes at compile time",
            "By requiring all variables to be global"
          ],
          "correctIndex": 2,
          "explanation": "Rust uses lifetimes and scope analysis at compile time to ensure that references don’t outlive the data they point to, preventing dangling references."
        }
      ]
    },
    {
      "id": "slice-in-rust",
      "title": "Slices in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=dKymZbFp0ZQ&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=8&ab_channel=FrancescoCiulla",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson08.rs",
      "questions": [
        {
          "id": "slice-in-rust-q01",
          "questionText": "What is a slice in Rust?",
          "options": [
            "A view into part of a collection without owning it",
            "A fixed-size array that owns its data",
            "A mutable pointer to the heap",
            "A reference that copies the original data"
          ],
          "correctIndex": 0,
          "explanation": "A slice is a reference to a contiguous sequence of elements in a collection; it doesn’t own the data."
        },
        {
          "id": "slice-in-rust-q02",
          "questionText": "Why are slices considered memory efficient in Rust?",
          "options": [
            "They are stored on the heap",
            "They are compiled into machine code",
            "They do not store data themselves, only references",
            "They compress data at runtime"
          ],
          "correctIndex": 2,
          "explanation": "Slices only store a pointer and length, making them lightweight and efficient."
        },
        {
          "id": "slice-in-rust-q03",
          "questionText": "What does the range syntax `[1..4]` return when slicing a collection?",
          "options": [
            "Elements at indices 1 through 4, inclusive",
            "Elements at indices 0 through 3",
            "Elements at indices 1, 2, and 3",
            "Elements starting at index 4"
          ],
          "correctIndex": 2,
          "explanation": "`[1..4]` includes elements starting at index 1 up to, but not including, index 4."
        },
        {
          "id": "slice-in-rust-q04",
          "questionText": "What will happen if you try to mutate a collection after taking an immutable slice of it?",
          "options": [
            "Rust will allow it and apply the changes to both",
            "Rust will panic at runtime",
            "Rust will give a compile-time borrow checker error",
            "Rust will silently clone the data"
          ],
          "correctIndex": 2,
          "explanation": "Rust enforces strict borrowing rules: you can't mutate while an immutable reference exists."
        },
        {
          "id": "slice-in-rust-q05",
          "questionText": "What is the type of a string literal like `\"hello\"` in Rust?",
          "options": [
            "String",
            "&str",
            "char",
            "Vec<char>"
          ],
          "correctIndex": 1,
          "explanation": "String literals are string slices (`&str`) that are statically allocated."
        },
        {
          "id": "slice-in-rust-q06",
          "questionText": "Why is it generally better to use `&str` instead of `&String` in function parameters?",
          "options": [
            "`&str` avoids ownership issues",
            "`&str` works with both `String` and string literals",
            "`&String` requires heap allocation",
            "`&String` is deprecated"
          ],
          "correctIndex": 1,
          "explanation": "`&str` is more flexible because it can accept both owned strings and string literals via deref coercion."
        },
        {
          "id": "slice-in-rust-q07",
          "questionText": "What does the slice syntax `[4..]` return?",
          "options": [
            "The first four elements",
            "Elements from index 0 to 4 inclusive",
            "Elements from index 4 to the end",
            "A mutable reference to index 4"
          ],
          "correctIndex": 2,
          "explanation": "`[4..]` is a slice starting from index 4 to the end of the collection."
        },
        {
          "id": "slice-in-rust-q08",
          "questionText": "What does the Rust compiler do when conflicting borrows occur (e.g., immutable and mutable)?",
          "options": [
            "Allows the operation but warns",
            "Crashes at runtime",
            "Issues a compile-time error",
            "Silently clones the data"
          ],
          "correctIndex": 2,
          "explanation": "Rust enforces borrowing rules at compile time to prevent data races and invalid memory access."
        }
      ]
    },
    {
      "id": "structs-in-rust",
      "title": "Structs in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=PCjuO-Bv5FI&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=9&ab_channel=FrancescoCiulla",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson09.rs",
      "questions": [
        {
          "id": "structs-in-rust-q01",
          "questionText": "What is a struct in Rust primarily used for?",
          "options": [
            "To define a single number with precision",
            "To group multiple values with different types using named fields",
            "To execute asynchronous tasks",
            "To define custom error handlers"
          ],
          "correctIndex": 1,
          "explanation": "Structs are used to group multiple values with different types under named fields, creating custom data types."
        },
        {
          "id": "structs-in-rust-q02",
          "questionText": "How are structs different from tuples in Rust?",
          "options": [
            "Structs are less memory efficient than tuples",
            "Tuples require named fields, structs don’t",
            "Structs have named fields, while tuples do not",
            "There is no difference"
          ],
          "correctIndex": 2,
          "explanation": "Structs have named fields which improve readability, whereas tuples use positional indexing."
        },
        {
          "id": "structs-in-rust-q03",
          "questionText": "What is true about the mutability of structs in Rust?",
          "options": [
            "Struct fields are always mutable",
            "You can make individual fields mutable",
            "The entire struct must be declared mutable to mutate any field",
            "Structs can’t be made mutable"
          ],
          "correctIndex": 2,
          "explanation": "You must declare the entire struct instance as mutable (`let mut`) to change any of its fields."
        },
        {
          "id": "structs-in-rust-q04",
          "questionText": "What is 'field init shorthand' in Rust?",
          "options": [
            "Using default values in structs",
            "Using the same name for parameter and field to skip repetition",
            "Skipping data types in struct definition",
            "Omitting fields entirely"
          ],
          "correctIndex": 1,
          "explanation": "If the field name matches the parameter name, Rust allows shorthand by just writing the field name."
        },
        {
          "id": "structs-in-rust-q05",
          "questionText": "What happens when a struct field like `email: String` is moved to a new instance?",
          "options": [
            "The value is cloned automatically",
            "Ownership is transferred and the original becomes invalid",
            "Nothing happens",
            "Rust creates a reference by default"
          ],
          "correctIndex": 1,
          "explanation": "Moving a `String` field transfers ownership. The original struct can no longer use that field unless it was cloned."
        },
        {
          "id": "structs-in-rust-q06",
          "questionText": "What is the purpose of tuple structs in Rust?",
          "options": [
            "To enable inheritance between structs",
            "To define multiple values with types but no field names",
            "To group values under a common enum",
            "To define multi-threaded collections"
          ],
          "correctIndex": 1,
          "explanation": "Tuple structs look like tuples but are defined with the `struct` keyword and give meaning to grouped data types."
        },
        {
          "id": "structs-in-rust-q07",
          "questionText": "Why might you use a unit-like struct in Rust?",
          "options": [
            "To define a struct with unknown fields for now",
            "To create a dynamic array",
            "To store floating-point numbers",
            "To define a numeric constant"
          ],
          "correctIndex": 0,
          "explanation": "A unit-like struct has no fields and is used when you want a type with a known identity but no data—useful for markers or placeholders."
        },
        {
          "id": "structs-in-rust-q08",
          "questionText": "Which of the following describes a valid reason to use `#[derive(Debug)]` on a struct?",
          "options": [
            "To create new methods for the struct",
            "To allow the struct to be printed using `println!` with `{:?}`",
            "To avoid writing a constructor",
            "To make all fields public by default"
          ],
          "correctIndex": 1,
          "explanation": "`#[derive(Debug)]` enables formatting the struct using the `{:?}` formatter, which is helpful for debugging."
        },
        {
          "id": "structs-in-rust-q09",
          "questionText": "What does the `build_user` function pattern typically do in Rust?",
          "options": [
            "Parses user input from the command line",
            "Initializes a struct, optionally with default values",
            "Encrypts user data before storage",
            "Clones a struct instance"
          ],
          "correctIndex": 1,
          "explanation": "A `build_user` function is often used to create instances of a struct, possibly filling in default values for some fields."
        }
      ]
    },
    {
      "id": "structs-example",
      "title": "Using Structs to Improve Code Clarity",
      "resourceUrl": "https://www.youtube.com/watch?v=mgK5LezkHl8&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=10&ab_channel=FrancescoCiulla",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson10.rs",
      "questions": [
        {
          "id": "structs-example-01",
          "questionText": "What is a major drawback of using separate variables (e.g., `width`, `height`) to represent a rectangle?",
          "options": [
            "Rust does not support multiple variables in a function.",
            "It is easier to make mistakes by mixing up values.",
            "Separate variables cannot be used in calculations.",
            "Functions cannot accept more than one parameter."
          ],
          "correctIndex": 1,
          "explanation": "Using separate variables can lead to bugs when passing them around or swapping them unintentionally."
        },
        {
          "id": "structs-example-02",
          "questionText": "What is one limitation of using tuples to represent a rectangle (e.g., `(30, 50)`)?",
          "options": [
            "Tuples cannot be passed into functions.",
            "Tuples are slower than structs.",
            "Tuple fields don’t have names, reducing code clarity.",
            "Tuples cannot hold integers."
          ],
          "correctIndex": 2,
          "explanation": "Tuples don’t have named fields, making it hard to understand which value represents what."
        },
        {
          "id": "structs-example-03",
          "questionText": "What is one primary advantage of using a struct to represent a rectangle?",
          "options": [
            "Structs run faster than functions.",
            "Structs remove the need for types.",
            "Structs allow named fields, making code easier to read and maintain.",
            "Structs cannot be passed by reference."
          ],
          "correctIndex": 2,
          "explanation": "Structs provide clarity through named fields like `width` and `height`, making code self-documenting."
        },
        {
          "id": "structs-example-04",
          "questionText": "Why does printing a struct instance using `println!` result in a compile-time error unless a trait is added?",
          "options": [
            "Printing structs is only available in nightly Rust.",
            "Structs need to be serialized before printing.",
            "The `Debug` trait must be derived to allow formatted printing.",
            "Rust does not support printing custom types."
          ],
          "correctIndex": 2,
          "explanation": "To print structs using `println!(\"{:?}\", ...)`, you must derive the `Debug` trait using `#[derive(Debug)]`."
        },
        {
          "id": "structs-example-05",
          "questionText": "What is the purpose of using `#[derive(Debug)]` above a struct definition?",
          "options": [
            "It allows the struct to be stored in memory.",
            "It gives all fields default values.",
            "It enables the struct to be printed with debug formatting.",
            "It marks the struct as immutable."
          ],
          "correctIndex": 2,
          "explanation": "`#[derive(Debug)]` allows the struct to be printed using debug formatting in output."
        },
        {
          "id": "structs-example-06",
          "questionText": "What is the role of `&` when passing a struct to a function in Rust?",
          "options": [
            "It clones the struct.",
            "It creates a new instance of the struct.",
            "It passes the struct by reference, avoiding ownership issues.",
            "It converts the struct to a tuple."
          ],
          "correctIndex": 2,
          "explanation": "Using `&` passes the struct by reference, which avoids moving ownership and is more efficient."
        },
        {
          "id": "structs-example-07",
          "questionText": "What advantage does the named-field structure of a struct offer when working in teams?",
          "options": [
            "Structs compile faster than tuples.",
            "Named fields make it easier for others to understand what each value represents.",
            "Structs support JavaScript-like dynamic typing.",
            "Team members can skip writing function signatures."
          ],
          "correctIndex": 1,
          "explanation": "Named fields provide semantic meaning to each value, making collaboration and maintenance easier."
        },
        {
          "id": "structs-example-08",
          "questionText": "What happens if you try to print a struct with `println!` without implementing or deriving `Debug`?",
          "options": [
            "It prints a default placeholder.",
            "It compiles but outputs an empty string.",
            "It results in a compile-time error.",
            "It automatically converts to a tuple."
          ],
          "correctIndex": 2,
          "explanation": "Rust requires structs to implement the `Debug` trait in order to use `println!(\"{:?}\", ...)`."
        },
        {
          "id": "structs-example-09",
          "questionText": "Why might using structs be beneficial when modeling real-world concepts like players in a game or app settings?",
          "options": [
            "Structs are the only types that support integers.",
            "Structs automatically derive traits like Clone.",
            "Structs provide a structured, type-safe way to group related data.",
            "Structs require less memory than other data types."
          ],
          "correctIndex": 2,
          "explanation": "Structs offer a clean and type-safe way to represent complex real-world entities."
        },
        {
          "id": "structs-example-10",
          "questionText": "What Rust syntax allows you to add built-in behaviors like debug-printing or cloning to structs?",
          "options": [
            "impl struct {...}",
            "#[use(debug)]",
            "#[derive(...)]",
            "fn derive() {...}"
          ],
          "correctIndex": 2,
          "explanation": "Rust uses the `#[derive(...)]` syntax to add common traits like `Debug`, `Clone`, and `Copy` to structs."
        }
      ]
    },
    {
      "id": "rust-methods",
      "title": "Methods in Rust",
      "resourceUrl": "https://www.youtube.com/watch?v=94iSHoKmPmY&list=PLPoSdR46FgI412aItyJhj2bF66cudB6Qs&index=11&ab_channel=FrancescoCiulla",
      "gitHubNotes": "https://github.com/grmbyrn/rust-notes/blob/main/src/lessons/lesson11.rs",
      "questions": [
        {
          "id": "rust-methods-q01",
          "questionText": "What distinguishes a method from a function in Rust?",
          "options": [
            "A method is defined inside a struct and takes self as the first parameter.",
            "A method is a type of macro used to manipulate struct data.",
            "A method cannot return values, while functions can.",
            "Methods must be private to the struct."
          ],
          "correctIndex": 0,
          "explanation": "In Rust, methods are associated with a struct (or enum) and take `self` (or `&self` / `&mut self`) as the first parameter, allowing them to operate on instances of the type."
        },
        {
          "id": "rust-methods-q02",
          "questionText": "What does the `&self` parameter in a method indicate?",
          "options": [
            "The method consumes the struct entirely.",
            "The method takes a mutable reference to the struct.",
            "The method takes an immutable reference to the struct.",
            "The method copies the struct into a new instance."
          ],
          "correctIndex": 2,
          "explanation": "`&self` means the method takes an immutable reference to the instance, allowing read-only access to its fields."
        },
        {
          "id": "rust-methods-q03",
          "questionText": "What is an associated function in Rust?",
          "options": [
            "A function defined inside `fn main()`.",
            "A method that only works with mutable structs.",
            "A function in an `impl` block that does not take `self` as the first parameter.",
            "A trait function that must be implemented by a struct."
          ],
          "correctIndex": 2,
          "explanation": "An associated function is defined within an `impl` block but does not take `self`, so it's called on the type itself rather than an instance."
        },
        {
          "id": "rust-methods-q04",
          "questionText": "Which syntax is used to call an associated function?",
          "options": [
            "structName.functionName()",
            "functionName::structName()",
            "structName::functionName()",
            "functionName(structName)"
          ],
          "correctIndex": 2,
          "explanation": "Associated functions are called using `StructName::functionName()`, since they don't operate on an instance."
        },
        {
          "id": "rust-methods-q05",
          "questionText": "Why might you define a method with the same name as a struct field?",
          "options": [
            "To override the field and hide its value.",
            "To make a getter method that can access private fields.",
            "To enable destructuring of the struct.",
            "To improve performance by inlining the field."
          ],
          "correctIndex": 1,
          "explanation": "Rust allows private fields, so you can create a public method with the same name to expose the value through a getter."
        },
        {
          "id": "rust-methods-q06",
          "questionText": "What is the purpose of the `can_hold` method in the lesson?",
          "options": [
            "To check if one rectangle can be cloned into another.",
            "To compare two rectangles for exact equality.",
            "To check if one rectangle can fit entirely inside another.",
            "To resize a rectangle to match another."
          ],
          "correctIndex": 2,
          "explanation": "`can_hold` compares the dimensions of two rectangles to determine if one can fully contain the other."
        },
        {
          "id": "rust-methods-q07",
          "questionText": "What is returned by the `Rectangle::square` function?",
          "options": [
            "A tuple representing width and height.",
            "A new Rectangle instance with equal width and height.",
            "A string describing the square.",
            "A reference to a Rectangle defined elsewhere."
          ],
          "correctIndex": 1,
          "explanation": "`Rectangle::square` is an associated function that creates a new `Rectangle` instance where width and height are the same."
        },
        {
          "id": "rust-methods-q08",
          "questionText": "Why might you use multiple `impl` blocks for a struct?",
          "options": [
            "To separate logic for different traits or purposes.",
            "To reduce compilation time.",
            "To allow parallel execution of methods.",
            "To add support for dynamic dispatch."
          ],
          "correctIndex": 0,
          "explanation": "Multiple `impl` blocks help organize code by grouping methods or trait implementations separately for readability and maintainability."
        },
        {
          "id": "rust-methods-q09",
          "questionText": "What happens if you define a method that takes `self` instead of `&self`?",
          "options": [
            "It takes ownership of the struct instance.",
            "It allows direct mutation of the struct fields.",
            "It borrows the struct immutably.",
            "It makes the struct immutable forever."
          ],
          "correctIndex": 0,
          "explanation": "`self` means the method takes ownership of the instance, consuming it, and it's no longer usable afterward unless returned."
        },
        {
          "id": "rust-methods-q10",
          "questionText": "What kind of return value is common in getter methods?",
          "options": [
            "Nothing (unit type)",
            "A string describing the field",
            "The value of a field in the struct",
            "A mutable reference to the whole struct"
          ],
          "correctIndex": 2,
          "explanation": "Getter methods typically return the value of a field, allowing read access even if the field itself is private."
        }
      ]
    }
  ]
}